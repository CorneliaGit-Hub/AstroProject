Rapport des fichiers Python dans : /mnt/e/CALENDAR/astro

Dossier : /mnt/e/CALENDAR/astro
==============================

Fichier : extract_variables.py
-----------------------------
import ast
import os

def extract_classes_and_variables_from_file(file_path):
    with open(file_path, 'r') as file:
        tree = ast.parse(file.read(), filename=file_path)
    classes = {"global_variables": []}
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            class_name = node.name
            classes[class_name] = {"attributes": [], "methods": []}
            for child in node.body:
                if isinstance(child, ast.FunctionDef):
                    classes[class_name]["methods"].append(child.name)
                elif isinstance(child, ast.Assign):
                    for target in child.targets:
                        if isinstance(target, ast.Name):
                            classes[class_name]["attributes"].append(target.id)
        elif isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name):
                    classes["global_variables"].append(target.id)
    return classes

def extract_functions_from_file(file_path):
    with open(file_path, 'r') as file:
        tree = ast.parse(file.read(), filename=file_path)
    functions = []
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            functions.append(node.name)
    return functions

def scan_project_directory(directory):
    all_details = {}
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                classes = extract_classes_and_variables_from_file(file_path)
                functions = extract_functions_from_file(file_path)
                all_details[file_path] = {"classes": classes, "functions": functions}
    return all_details

if __name__ == "__main__":
    project_directories = ["/mnt/e/CALENDAR/astro/astroapp", "/mnt/e/CALENDAR/astro/astroconfig"]
    all_details = {}
    for directory in project_directories:
        details = scan_project_directory(directory)
        all_details.update(details)

    for file, details in all_details.items():
        print(f"\nFile: {file}")
        if details["classes"]:
            for class_name, class_details in details["classes"].items():
                if class_name == "global_variables":
                    print(f"  Global Variables: {class_details}")
                else:
                    print(f"  Class: {class_name}")
                    print(f"    Attributes: {class_details['attributes']}")
                    print(f"    Methods: {class_details['methods']}")
        if details["functions"]:
            print(f"  Functions: {details['functions']}")



Fichier : manage.py
------------------
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys

def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'astroconfig.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()


Dossier : /mnt/e/CALENDAR/astro/astroapp
=======================================

Fichier : admin.py
-----------------
from django.contrib import admin
from .models import ThemeAstrologique

admin.site.register(ThemeAstrologique)


Fichier : analyse_astroapp.py
----------------------------
import os
import re

# Chemin du dossier de l'application
app_folder = r"/mnt/e/CALENDAR/astro/astroapp"
excluded_files = {"views_functions_variables.py", "extract_html_dependencies.py", "views.py", "analyse_astroapp.py"}

# Regex patterns pour chaque extraction sp√©cifique
function_pattern = re.compile(r"def\s+(\w+)\s*\(.*?\):")
variable_pattern = re.compile(r"^(\w+)\s*=\s*")
admin_register_pattern = re.compile(r"admin\.site\.register\((\w+)\)")
url_pattern = re.compile(r"path\('([^']+)',\s*views\.(\w+),\s*name='([^']+)'")
model_class_pattern = re.compile(r"class\s+(\w+)\(models\.Model\):")
model_field_pattern = re.compile(r"(\w+)\s*=\s*models\.(\w+)\(.*?\)")

# Dictionnaire pour stocker les r√©sultats
extracted_data = {}

# Parcours des fichiers Python dans le dossier
for root, _, files in os.walk(app_folder):
    for file_name in files:
        if file_name.endswith(".py") and file_name not in excluded_files:
            file_path = os.path.join(root, file_name)
            extracted_data[file_name] = {
                "functions": [],
                "variables": [],
                "admin_register": [],
                "urls": [],
                "models": {}
            }
            
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    lines = f.readlines()
                    current_model = None  # Suivi de la classe actuelle dans models.py
                    
                    for line in lines:
                        # Recherche de fonctions
                        if function_match := function_pattern.search(line):
                            extracted_data[file_name]["functions"].append(function_match.group(1))
                        
                        # Recherche de variables globales
                        if variable_match := variable_pattern.search(line):
                            extracted_data[file_name]["variables"].append(variable_match.group(1))
                        
                        # Recherche des enregistrements admin
                        if admin_register_match := admin_register_pattern.search(line):
                            extracted_data[file_name]["admin_register"].append(admin_register_match.group(1))
                        
                        # Recherche des chemins d'URL
                        if url_match := url_pattern.search(line):
                            extracted_data[file_name]["urls"].append({
                                "url": url_match.group(1),
                                "view": url_match.group(2),
                                "name": url_match.group(3)
                            })
                        
                        # D√©tection de classes de mod√®le
                        if model_class_match := model_class_pattern.search(line):
                            current_model = model_class_match.group(1)
                            extracted_data[file_name]["models"][current_model] = {"fields": [], "methods": []}
                        
                        # D√©tection des champs de mod√®le
                        if current_model and (field_match := model_field_pattern.search(line)):
                            extracted_data[file_name]["models"][current_model]["fields"].append((field_match.group(1), field_match.group(2)))
                        
                        # D√©tection des m√©thodes de mod√®le
                        if current_model and line.strip().startswith("def "):
                            method_match = function_pattern.search(line)
                            if method_match:
                                extracted_data[file_name]["models"][current_model]["methods"].append(method_match.group(1))
            except Exception as e:
                print(f"Erreur lors de la lecture du fichier {file_name}: {e}")

# Affichage des r√©sultats dans la console
for file_name, data in extracted_data.items():
    print(f"\nFICHIER : {file_name}")
    
    # Fonctions
    if data["functions"]:
        print("  FONCTIONS:")
        for func_name in data["functions"]:
            print(f"    - {func_name}")
    
    # Variables
    if data["variables"]:
        print("  VARIABLES:")
        for var_name in data["variables"]:
            print(f"    - {var_name}")
    
    # Admin Registration
    if data["admin_register"]:
        print("  ENREGISTREMENTS ADMIN:")
        for model_name in data["admin_register"]:
            print(f"    - {model_name}")
    
    # URLs
    if data["urls"]:
        print("  URLS:")
        for url_info in data["urls"]:
            print(f"    - URL: {url_info['url']}, Vue: {url_info['view']}, Nom: {url_info['name']}")
    
    # Mod√®les
    if data["models"]:
        print("  MOD√àLES:")
        for model_name, model_data in data["models"].items():
            print(f"    - Mod√®le: {model_name}")
            print("      Champs:")
            for field_name, field_type in model_data["fields"]:
                print(f"        - {field_name}: {field_type}")
            print("      M√©thodes:")
            for method_name in model_data["methods"]:
                print(f"        - {method_name}")



Fichier : apps.py
----------------


Fichier : extract_html_dependencies.py
-------------------------------------
import os
import re

def extract_dependencies(template_dirs):
    # Stockage des d√©pendances par fichier
    dependencies = {}
    
    # Parcourir tous les fichiers HTML dans les r√©pertoires des templates fournis
    for template_dir in template_dirs:
        for root, dirs, files in os.walk(template_dir):
            for file in files:
                if file.endswith(".html"):
                    file_path = os.path.join(root, file)
                    with open(file_path, "r", encoding="utf-8") as f:
                        content = f.read()
                        
                        # Stocker les d√©pendances pour ce fichier
                        dependencies[file] = {
                            "includes": set(),
                            "variables": set(),
                            "conditionals": set(),
                            "urls": set(),
                            "forms": set()
                        }
                        
                        # Rechercher les inclusions et statiques
                        includes = re.findall(r'{% (include|static) ["\'](.+?)["\'] %}', content)
                        dependencies[file]["includes"].update([inc[1] for inc in includes])
                        
                        # Rechercher les variables inject√©es
                        variables = re.findall(r'{{ (.+?) }}', content)
                        dependencies[file]["variables"].update(variables)
                        
                        # Rechercher les conditionnels et boucles, sans r√©p√©titions
                        conditionals = re.findall(r'{% if (.+?) %}', content)
                        loops = re.findall(r'{% for (.+?) in (.+?) %}', content)
                        dependencies[file]["conditionals"].update(conditionals)
                        dependencies[file]["conditionals"].update([f"{item} in {collection}" for item, collection in loops])

                        # Rechercher les liens URL
                        urls = re.findall(r'{% url ["\']?(\w+)["\']? %}', content)
                        dependencies[file]["urls"].update(urls)

                        # Rechercher les formulaires et leurs actions
                        forms = re.findall(r'<form.*?action=["\']{% url ["\']?(\w+)["\']? %}["\'].*?>', content, re.DOTALL)
                        dependencies[file]["forms"].update(forms)
    
    # Affichage format√©
    for html_file, data in dependencies.items():
        print(f"\n{html_file}")
        
        # Conditionnels et Boucles
        if data["conditionals"]:
            print("‚Ä¢ Conditionnels et Boucles :")
            for idx, conditional in enumerate(data["conditionals"], start=1):
                if " in " in conditional:
                    print(f"{idx}. {conditional} : ")
                    print(f"{{% for {conditional} %}} ... {{% endfor %}}")
                else:
                    print(f"{idx}. {conditional} : ")
                    print(f"{{% if {conditional} %}} ... {{% endif %}}")
        
        # URLs d√©tect√©es
        if data["urls"]:
            print("‚Ä¢ URLs d√©tect√©es :")
            for idx, url in enumerate(data["urls"], start=1):
                print(f"{idx}. {url} : ")
                print(f"{{% url '{url}' %}}")
        
        # Variables d√©tect√©es
        if data["variables"]:
            print("‚Ä¢ Variables d√©tect√©es :")
            for idx, variable in enumerate(data["variables"], start=1):
                print(f"{idx}. {variable} : ")
                print(f"{{{{ {variable} }}}}")

        # Inclusions
        if data["includes"]:
            print("‚Ä¢ Inclusions externes :")
            for idx, include in enumerate(data["includes"], start=1):
                print(f"{idx}. {include} : ")
                print(f"{{% include '{include}' %}}")

        # Formulaires et actions
        if data["forms"]:
            print("‚Ä¢ Formulaires et actions :")
            for idx, form in enumerate(data["forms"], start=1):
                print(f"{idx}. {form} : ")
                print(f"<form method='post' action='{{% url '{form}' %}}'>")

# Dossiers des templates √† v√©rifier
template_dirs = [
    "/mnt/e/CALENDAR/astro/astroapp/templates",
    "/mnt/e/CALENDAR/astro/astroapp/templates/registration"
]

# Extraction des d√©pendances
extract_dependencies(template_dirs)


Fichier : forms.py
-----------------


Fichier : generate_code_report_by_files.py
-----------------------------------------
import os

def generate_code_report_by_files(base_path="/mnt/e/CALENDAR/astro", output_file="code_report.txt"):
    """
    G√©n√®re un rapport des codes source des fichiers Python dans un dossier donn√© et ses sous-dossiers.
    Le rapport est organis√© par dossiers et fichiers.
    """
    try:
        with open(output_file, "w", encoding="utf-8") as report:
            report.write(f"Rapport des fichiers Python dans : {base_path}\n\n")
            
            for root, dirs, files in os.walk(base_path):
                report.write(f"Dossier : {root}\n")
                report.write("=" * (9 + len(root)) + "\n")
                for file in files:
                    if file.endswith(".py"):
                        file_path = os.path.join(root, file)
                        report.write(f"\nFichier : {file}\n")
                        report.write("-" * (9 + len(file)) + "\n")
                        try:
                            with open(file_path, "r", encoding="utf-8") as py_file:
                                report.write(py_file.read())
                        except Exception as e:
                            report.write(f"Erreur lors de la lecture du fichier : {e}\n")
                        report.write("\n")
                report.write("\n")
        
        print(f"Rapport g√©n√©r√© avec succ√®s dans : {output_file}")

    except Exception as e:
        print(f"Erreur lors de la g√©n√©ration du rapport : {e}")

if __name__ == "__main__":
    # Le chemin est d√©fini par d√©faut pour `/mnt/e/CALENDAR/astro`
    generate_code_report_by_files()


Fichier : generer_arbre_du_logiciel.py
-------------------------------------
import os

def generer_arbre(repertoire, niveau=0):
    """Parcourt le r√©pertoire et affiche son contenu sous forme d'arborescence."""
    try:
        for element in os.listdir(repertoire):
            chemin = os.path.join(repertoire, element)
            # Indenter selon le niveau
            indentation = "    " * niveau
            # Afficher les dossiers et fichiers
            if os.path.isdir(chemin):
                print(f"{indentation}üìÇ {element}/")
                generer_arbre(chemin, niveau + 1)
            else:
                print(f"{indentation}üìÑ {element}")
    except PermissionError:
        print(f"Permission refus√©e pour acc√©der √† : {repertoire}")

def sauvegarder_arbre(repertoire, fichier_sortie):
    """Enregistre l'arborescence dans un fichier."""
    with open(fichier_sortie, 'w', encoding='utf-8') as fichier:
        original_stdout = os.sys.stdout
        os.sys.stdout = fichier
        try:
            generer_arbre(repertoire)
        finally:
            os.sys.stdout = original_stdout

if __name__ == "__main__":
    # Chemin du r√©pertoire racine (remplace par ton chemin de projet)
    chemin_projet = input("Entrez le chemin du projet : ").strip()
    
    # Nom du fichier pour sauvegarder l'arbre
    fichier_sortie = "arbre_du_logiciel.txt"
    
    # G√©n√©rer et afficher l'arbre dans la console
    print("\nArborescence du logiciel :\n")
    generer_arbre(chemin_projet)
    
    # Sauvegarder l'arbre dans un fichier
    sauvegarder_arbre(chemin_projet, fichier_sortie)
    print(f"\nArborescence enregistr√©e dans le fichier : {fichier_sortie}")


Fichier : models.py
------------------
from django.db import models
from django.contrib.auth.models import User

class ThemeAstrologique(models.Model):
    utilisateur = models.ForeignKey(User, on_delete=models.CASCADE)
    nom_du_theme = models.CharField(max_length=255)
    date_de_creation = models.DateTimeField(auto_now_add=True)
    date_naissance = models.DateField(default='2000-01-01')  # Valeur par d√©faut ajout√©e
    heure_naissance = models.TimeField(default='00:00:00')  # Valeur par d√©faut ajout√©e
    pays = models.CharField(max_length=255)
    ville = models.CharField(max_length=255)

    def __str__(self):
        return f"{self.nom_du_theme} ({self.utilisateur.username})"



Fichier : urls.py
----------------
from django.urls import path, include
from . import views


urlpatterns = [
    path('birth_data/', views.birth_data, name='birth_data'),  # Vue pour traiter et afficher les donn√©es de naissance
    path('planetary_position/', views.planetary_position, name='planetary_position'),  # Vue pour afficher les positions plan√©taires
    path('birth_results/', views.display_astrological_wheel, name='birth_results'),
    path('birth_results/text/', views.birth_results, name='birth_results_text'),
    path('connexion/', views.connexion, name='connexion'),
    path('inscription/', views.inscription, name='inscription'),
    path('deconnexion/', views.deconnexion, name='deconnexion'),
]


Fichier : views.py
-----------------
import pytz
from timezonefinder import TimezoneFinder
from geopy.geocoders import Nominatim
from datetime import datetime
import swisseph as swe
from zoneinfo import ZoneInfo
from django.http import HttpResponse
from django.conf import settings
import os
import time
import matplotlib
matplotlib.use('Agg')  # Utiliser le backend sans interface graphique pour Matplotlib
import matplotlib.pyplot as plt  # Import une seule fois
import numpy as np
from matplotlib import font_manager
from matplotlib import patches  # Ajout du module patches pour dessiner les segments
import matplotlib.patches as patches
from django.utils.timezone import now
timestamp = int(now().timestamp())
from django.shortcuts import render, redirect
from .models import ThemeAstrologique
from django.contrib.auth import login, authenticate, logout
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.urls import reverse
from urllib.parse import urlencode
import json
from django.utils.http import urlencode

# ENREGISTRER UN THEME
# CONNEXION
def inscription(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('birth_data')  # Redirige vers le formulaire de donn√©es de naissance
    else:
        form = UserCreationForm()
    return render(request, 'registration/signup.html', {'form': form})


def connexion(request):
    if request.method == 'POST':
        form = AuthenticationForm(data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect('birth_data')  # Redirige vers le formulaire de donn√©es de naissance
    else:
        form = AuthenticationForm()
    return render(request, 'registration/login.html', {'form': form})

def deconnexion(request):
    logout(request)
    return redirect('birth_data')  # Redirige vers birth_data apr√®s la d√©connexion



# ZODIAQUE
# Fonction pour retourner l'image de la roue zodiacale
def zodiac_wheel(request):
    image_path = os.path.join(settings.BASE_DIR, 'static', 'images', 'zodiac_wheel.png')
    with open(image_path, 'rb') as f:
        return HttpResponse(f.read(), content_type="image/png")

# 1- Fonction pour obtenir le signe astrologique √† partir d'un degr√©
def get_zodiac_sign(degree):
    signs = [
        "B√©lier", "Taureau", "G√©meaux", "Cancer", "Lion", "Vierge",
        "Balance", "Scorpion", "Sagittaire", "Capricorne", "Verseau", "Poissons"
    ]
    sign_index = int(degree // 30)
    sign_degree = degree % 30
    return signs[sign_index], sign_degree





# PLANETES 
def calculate_single_planet_position(jd, planet_id):
    """Calcule la position d'une plan√®te en fonction du jour julien."""
    position, _ = swe.calc_ut(jd, planet_id)
    degree = position[0]
    sign, sign_degree = get_zodiac_sign(degree)

    # Afficher la position pour d√©bogage
    print(f"D√©bogage : Plan√®te ID {planet_id} - Degr√© :", degree, ", Signe :", sign, ", Degr√© dans le signe :", sign_degree)

    planet_data = {
        'degree': degree,
        'sign': sign,
        'sign_degree': sign_degree,
    }
    return planet_data, degree


def calculate_single_planet_position(jd, planet_id):
    """Calcule la position d'une plan√®te en fonction du jour julien."""
    position, _ = swe.calc_ut(jd, planet_id)
    degree = position[0]
    sign, sign_degree = get_zodiac_sign(degree)

    # Afficher la position pour d√©bogage
    print(f"D√©bogage : Plan√®te ID {planet_id} - Degr√© :", degree, ", Signe :", sign, ", Degr√© dans le signe :", sign_degree)

    planet_data = {
        'degree': degree,
        'sign': sign,
        'sign_degree': sign_degree,
    }
    return planet_data, degree


def format_planet_positions(results, planet_positions):
    """Pr√©pare les r√©sultats des positions plan√©taires pour le retour."""
    # Affiche les r√©sultats pour v√©rification
    print("D√©bogage : R√©sultats des positions des plan√®tes ->", results)
    print("D√©bogage : Positions des plan√®tes en liste ->", planet_positions)
    return results, planet_positions


# 2- Fonction pour calculer les positions des plan√®tes
def calculate_planet_positions(jd):
    planets = {
        'Soleil': swe.SUN,
        'Lune': swe.MOON,
        'Mercure': swe.MERCURY,
        'V√©nus': swe.VENUS,
        'Mars': swe.MARS,
        'Jupiter': swe.JUPITER,
        'Saturne': swe.SATURN,
        'Uranus': swe.URANUS,
        'Neptune': swe.NEPTUNE,
        'Pluton': swe.PLUTO,
    }
    results = {}
    planet_positions = []

    print("D√©bogage : Calcul des positions des plan√®tes pour le jour julien (JD) ->", jd)


    for planet_name, planet_id in planets.items():
        # Appel de la fonction pour calculer la position d'une plan√®te : def calculate_single_planet_position
        planet_data, planet_degree = calculate_single_planet_position(jd, planet_id)
        results[planet_name] = planet_data
        planet_positions.append((planet_name, planet_degree))


    # Appel de la fonction pour formater les r√©sultats avant de les renvoyer : def format_planet_positions(
    return format_planet_positions(results, planet_positions)
    

# 2-Fonction pour convertir les degr√©s en degr√©s, minutes et secondes
def convert_to_dms(degree):
    degrees = int(degree)
    minutes = int((degree - degrees) * 60)
    seconds = round(((degree - degrees) * 60 - minutes) * 60, 2)
    return degrees, minutes, seconds






# MAISONS
def format_house_cusp(cusp):
    """Formate les donn√©es de la cuspide d'une maison en fonction de son degr√©."""
    sign, sign_degree = get_zodiac_sign(cusp)
    degrees, minutes, seconds = convert_to_dms(cusp)
    return {
        'degree': cusp,
        'sign': sign,
        'sign_degree': sign_degree,
        'degree_dms': f"{degrees}¬∞{minutes}'{seconds}''"
    }


def get_asc_mc(ascmc):
    """R√©cup√®re les positions de l'Ascendant (ASC) et du Milieu du Ciel (MC) depuis les donn√©es ascmc."""
    asc = ascmc[0]
    mc = ascmc[1]
    return asc, mc


# 3- Fonction pour calculer les maisons astrologiques avec les degr√©s totaux et DMS
def calculate_houses(jd, latitude, longitude):
    # Utiliser les m√™mes fonctions de calcul que dans zodiacwheel.py
    house_cuspids, ascmc = swe.houses(jd, latitude, longitude, b'P')
    
    # Formater les r√©sultats comme dans zodiacwheel.py
    house_results = {}
    for i, cusp in enumerate(house_cuspids):
        # Appel de la fonction pour formater les donn√©es de la maison
        house_results[f'Maison {i + 1}'] = format_house_cusp(cusp)


    # Appel de la fonction pour obtenir l'ASC et le MC : def get_asc_mc(ascmc)
    asc, mc = get_asc_mc(ascmc)

    return house_results    





# GEOLOCALISATION
# Fonction pour obtenir la g√©olocalisation d'un lieu
def get_location(city, country):
    geolocator = Nominatim(user_agent="astroapp")
    location = geolocator.geocode(f"{city}, {country}", timeout=10)
    
    if not location:
        return None, "Lieu de naissance introuvable."
    # Ajoute ce print ici
    print("G√©olocalisation - Latitude :", location.latitude, "Longitude :", location.longitude)
    return location, None  # Retourne la localisation et None pour indiquer qu'il n'y a pas d'erreur

# Fonction pour obtenir le fuseau horaire d'une localisation
def get_timezone(latitude, longitude):
    tf = TimezoneFinder()
    timezone_str = tf.timezone_at(lng=longitude, lat=latitude)
    
    if not timezone_str:
        return None, "Fuseau horaire non trouv√©."
    
    return timezone_str, None  # Retourne le fuseau horaire et None pour indiquer qu'il n'y a pas d'erreur


def localize_datetime(birth_datetime, timezone_str):
    """G√®re la localisation de birth_datetime en tenant compte du fuseau horaire sp√©cifique."""
    if timezone_str == "America/Cayenne":
        timezone = pytz.timezone("Etc/GMT+3")
        return timezone.localize(birth_datetime)
    else:
        return birth_datetime.replace(tzinfo=ZoneInfo(timezone_str))


def convert_to_utc(local_datetime):
    """Convertit un datetime localis√© en heure UTC."""
    return local_datetime.astimezone(ZoneInfo("UTC"))


# Fonction pour convertir une date de naissance en heures locales et UTC
def convert_birth_datetime(birth_datetime, timezone_str):
    try:
        # Appel de la fonction pour convertir en heure locale :  def localize_datetime
        birth_datetime_local = localize_datetime(birth_datetime, timezone_str)
        
        # Appel de la fonction pour convertir l'heure locale en UTC : def convert_to_utc
        birth_datetime_utc, error = convert_to_utc(birth_datetime_local, timezone_str)  # Ajoute timezone_str

        # Si une erreur est d√©tect√©e, retourne l'erreur
        if error:
            return None, None, error
            
        # Ajoute ces prints ici
        print("Fuseau Horaire :", timezone_str)
        print("Date/Heure UTC :", birth_datetime_utc)
    
        # Retourne les dates locales et UTC sans erreur
        return birth_datetime_local, birth_datetime_utc, None

    except Exception as e:
        # En cas d'erreur, retourne None et le message d'erreur
        return None, None, f'Erreur de conversion : {e}'


# julian_day
def calculate_julian_day(birth_datetime_utc):
    """Calcule le jour julien (JD) √† partir d'une date UTC."""
    return swe.julday(
        birth_datetime_utc.year,
        birth_datetime_utc.month,
        birth_datetime_utc.day,
        birth_datetime_utc.hour + birth_datetime_utc.minute / 60.0
    )

def calculate_julian_day_and_planet_positions(birth_datetime_utc, latitude, longitude):

    # Appel de la fonction pour calculer le jour julien (JD) : def calculate_julian_day
    jd = calculate_julian_day(birth_datetime_utc)

    
    # Calcul des positions des plan√®tes
    results, planet_positions = calculate_planet_positions(jd)

    # Ajoute ce print ici
    print("Jour Julien Calcul√© :", jd)
    return jd, results, planet_positions


# Fonction pour calculer les maisons astrologiques
def calculate_astrological_houses(jd, latitude, longitude):
    # Utiliser les m√™mes fonctions de calcul que dans zodiacwheel.py
    house_results = calculate_houses(jd, latitude, longitude)
    
    return house_results



# ASPECTS
# Fonction pour calculer les aspects plan√©taires
def calculate_astrological_aspects(planet_positions):
    aspects = calculate_aspects(planet_positions)
    return aspects


def add_aspect_if_present(aspects, planet1, pos1, planet2, pos2, diff, aspect_definitions, aspect_orbs):
    """V√©rifie si un aspect existe entre deux positions plan√©taires et l'ajoute √† la liste des aspects."""
    for aspect_name, aspect_angle in aspect_definitions.items():
        orbe = aspect_orbs[aspect_name]
        if abs(diff - aspect_angle) <= orbe:
            aspects.append((aspect_name, pos1, pos2))


def calculate_angular_difference(pos1, pos2):
    """Calcule la diff√©rence angulaire minimale entre deux positions plan√©taires."""
    diff = abs(pos1 - pos2)
    return min(diff, 360 - diff)


# Fonction pour afficher les aspects plan√©taires
def calculate_aspects(planet_positions):
    aspects = []
    aspect_definitions = {
        'Conjonction': 0,
        'Sextile': 60,
        'Carr√©': 90,
        'Trigone': 120,
        'Opposition': 180,
    }
    aspect_orbs = {
        'Conjonction': 8,
        'Sextile': 6,
        'Carr√©': 6,
        'Trigone': 8,
        'Opposition': 8,
    }

    for i in range(len(planet_positions)):
        for j in range(i + 1, len(planet_positions)):
            planet1, pos1 = planet_positions[i]
            planet2, pos2 = planet_positions[j]
            
            # Appel la fonction qui Calcule la diff√©rence angulaire minimale entre deux positions
            diff = calculate_angular_difference(pos1, pos2)


            # Appel la focntion qui V√©rifie si un aspect est pr√©sent et l'ajoute s'il est d√©tect√© : def add_aspect_if_present
            add_aspect_if_present(aspects, planet1, pos1, planet2, pos2, diff, aspect_definitions, aspect_orbs)

    return aspects
    

def format_single_aspect(aspect_name, planet1, pos1, planet2, pos2, ecart):
    """Formate un aspect individuel en texte lisible."""
    return f"¬´ {aspect_name} ¬ª  {planet1} ({pos1:.2f}¬∞) et {planet2} ({pos2:.2f}¬∞), avec un √©cart de ¬´ {ecart:.2f}¬∞ ¬ª."


# Fonction pour formater les aspects en texte lisible avec les positions et l'√©cart en degr√©s
def format_aspects_text(aspects, planet_positions):
    # Dictionnaire pour retrouver le nom de la plan√®te √† partir de la position
    planet_dict = {position: name for name, position in planet_positions}
    
    formatted_aspects = []
    for aspect_name, pos1, pos2 in aspects:
        planet1 = planet_dict.get(pos1, "Inconnu")
        planet2 = planet_dict.get(pos2, "Inconnu")
        # Appel la focntion : def calculate_angular_difference
        ecart = calculate_angular_difference(pos1, pos2)

        # Appel de la fonction pour formater un aspect individuel ! def format_single_aspect
        formatted_aspects.append(format_single_aspect(aspect_name, planet1, pos1, planet2, pos2, ecart))
   
    return formatted_aspects


# DONNEES DE NAISSANCE
def extract_coordinates(location):
    """Extrait les coordonn√©es latitude et longitude d'un objet de localisation."""
    latitude = location.latitude
    longitude = location.longitude
    print("D√©bogage : Coordonn√©es extraites - latitude:", latitude, ", longitude:", longitude)
    return latitude, longitude

def retrieve_timezone(latitude, longitude):
    """R√©cup√®re le fuseau horaire pour des coordonn√©es donn√©es et g√®re les erreurs √©ventuelles."""
    timezone_str, error = get_timezone(latitude, longitude)
    if error:
        print("Erreur de fuseau horaire :", error)
    return timezone_str, error


def get_birth_location_data(city_of_birth, country_of_birth):
    # G√©olocalisation du lieu de naissance
    location, error = get_location(city_of_birth, country_of_birth)
    if error:
        print("Erreur de g√©olocalisation :", error)
        return None, None, None, None, error
    
    print("D√©bogage : Localisation obtenue ->", location)

    # Appel de la fonction pour extraire les coordonn√©es latitude et longitude : def extract_coordinates
    latitude, longitude = extract_coordinates(location)

    # Appel de la fonction pour r√©cup√©rer le fuseau horaire : def retrieve_timezone
    timezone_str, error = retrieve_timezone(latitude, longitude)

    
    print("D√©bogage : Fuseau horaire d√©tect√© ->", timezone_str)
    
    return location, latitude, longitude, timezone_str, None


def convert_latlon_to_dms(latitude, longitude):
    # Conversion des coordonn√©es en DMS (Degr√©s, Minutes, Secondes)
    latitude_dms = decimal_to_dms(latitude, is_latitude=True)
    longitude_dms = decimal_to_dms(longitude, is_latitude=False)
    print("D√©bogage : Coordonn√©es en DMS - latitude_dms:", latitude_dms, ", longitude_dms:", longitude_dms)
    return latitude_dms, longitude_dms


def convert_to_local_and_utc(birth_datetime, timezone_str):
    """Convertit une date de naissance en heures locales et UTC."""
    birth_datetime_local, birth_datetime_utc, error = convert_birth_datetime(birth_datetime, timezone_str)
    if error:
        print("Erreur de conversion datetime :", error)
        return None, None, error

    print("D√©bogage : Conversion datetime r√©ussie - Heure locale :", birth_datetime_local, ", Heure UTC :", birth_datetime_utc)
    return birth_datetime_local, birth_datetime_utc, None


def calculate_julian_and_positions(birth_datetime_utc):
    # Appel √† la fonciotn qui Calcule le jour julien (JD) : def calculate_julian_day
    jd = calculate_julian_day(birth_datetime_utc)
    print("D√©bogage : Jour julien calcul√© ->", jd)

    # Appel √† la fonciotn qui Calcule les positions des plan√®tes : def calculate_planet_positions(jd):
    results, planet_positions = calculate_planet_positions(jd)
    print("D√©bogage : Calcul des positions des plan√®tes termin√©. R√©sultats ->", results)

    return jd, results, planet_positions


def generate_aspects_and_text(planet_positions):
    # Calcul des aspects plan√©taires
    aspects = calculate_astrological_aspects(planet_positions)
    print("D√©bogage : Calcul des aspects plan√©taires termin√©. Aspects ->", aspects)

    # Formatage du texte des aspects
    aspects_text = format_aspects_text(aspects, planet_positions)
    print("D√©bogage - aspects_text :", aspects_text)
    
    return aspects, aspects_text


def prepare_theme_data_json(house_results, aspects, planet_positions):
    theme_data_json = json.dumps({
        'houses': house_results,
        'aspects': aspects,
        'planet_positions': planet_positions
    })
    print("D√©bogage : Contenu de theme_data_json ->", theme_data_json)
    return theme_data_json    


def extract_birth_data_form(request):
    name = request.POST['name']
    birthdate = request.POST['birthdate']
    birthtime = request.POST['birthtime']
    country_of_birth = request.POST['country_of_birth']
    city_of_birth = request.POST['city_of_birth']
    print("D√©bogage : Variables extraites - name:", name, ", birthdate:", birthdate, ", birthtime:", birthtime)
    print("D√©bogage : Localisation - ville:", city_of_birth, ", pays:", country_of_birth)
    return name, birthdate, birthtime, country_of_birth, city_of_birth
    

def create_birth_datetime_and_timestamp(birthdate, birthtime):
    birth_datetime_str = f"{birthdate} {birthtime}"
    birth_datetime = datetime.strptime(birth_datetime_str, "%Y-%m-%d %H:%M")
    print("D√©bogage : birth_datetime construit ->", birth_datetime)

    # Cr√©ation du timestamp pour rechargement de l'image
    timestamp = int(now().timestamp())
    print("D√©bogage : Timestamp ajout√© ->", timestamp)
    
    return birth_datetime, timestamp


def convert_coordinates_to_dms(latitude, longitude):
    latitude_dms, longitude_dms = convert_latlon_to_dms(latitude, longitude)
    return latitude_dms, longitude_dms


def prepare_template_context(name, results, house_results, aspects, aspects_text, birth_datetime_local, birth_datetime_utc, location, latitude_dms, longitude_dms, theme_data_json):
    return {
        'name': name,
        'results': results,
        'houses': house_results,
        'aspects': aspects,
        'aspects_text': aspects_text,
        'local_year_str': birth_datetime_local.strftime("%Y"),
        'local_time_str': birth_datetime_local.strftime("%H:%M:%S %Z%z"),
        'utc_time_str': birth_datetime_utc.strftime("%H:%M:%S %Z%z"),
        'location': location,
        'latitude_dms': latitude_dms,
        'longitude_dms': longitude_dms,
        'theme_data_json': theme_data_json
    }


def birth_data(request):
    if request.method == 'POST':
        print("D√©bogage : Vue 'birth_data' appel√©e.")

        # Appel pour extraire les donn√©es du formulaire
        name, birthdate, birthtime, country_of_birth, city_of_birth = extract_birth_data_form(request)
        print("D√©bogage : Donn√©es POST re√ßues ->", request.POST)

        # Appel pour cr√©er l'objet datetime de naissance et le timestamp
        birth_datetime, timestamp = create_birth_datetime_and_timestamp(birthdate, birthtime)

        # Appel pour obtenir la g√©olocalisation et le fuseau horaire
        location, latitude, longitude, timezone_str, error = get_birth_location_data(city_of_birth, country_of_birth)
        if error:
            return render(request, 'birth_data_form.html', {'error': error})

        # Appel pour convertir les coordonn√©es en DMS (degr√©s, minutes, secondes)
        latitude_dms, longitude_dms = convert_coordinates_to_dms(latitude, longitude)

        # Appel pour convertir en heures locales et UTC
        birth_datetime_local, birth_datetime_utc, error = convert_to_local_and_utc(birth_datetime, timezone_str)
        if error:
            return render(request, 'birth_data_form.html', {'error': error})

        # Appel pour calculer le jour julien (JD) et les positions des plan√®tes
        jd, results, planet_positions = calculate_julian_and_positions(birth_datetime_utc)

        # Appel pour calculer les maisons astrologiques
        house_results = calculate_astrological_houses(jd, latitude, longitude)
        print("D√©bogage : Calcul des maisons astrologiques termin√©.")

        # Appel pour calculer les aspects plan√©taires et formater le texte des aspects
        aspects, aspects_text = generate_aspects_and_text(planet_positions)
        
        print("Avant enregistrement - Type et valeur de planet_positions :", type(planet_positions), planet_positions)
        print("Avant enregistrement - Type et valeur de aspects :", type(aspects), aspects)
        print("Avant enregistrement - Type et valeur de house_results :", type(house_results), house_results)


        # Appel pour pr√©parer les donn√©es du th√®me en JSON pour le template
        theme_data_json = prepare_theme_data_json(house_results, aspects, planet_positions)
        
        print("Apr√®s enregistrement - Type et valeur de planet_positions :", type(planet_positions), planet_positions)
        print("Apr√®s enregistrement - Type et valeur de aspects :", type(aspects), aspects)
        print("Apr√®s enregistrement - Type et valeur de house_results :", type(house_results), house_results)


        # Appel pour g√©n√©rer la roue astrologique visuelle
        print("D√©bogage : G√©n√©ration de la roue astrologique.")
        generate_astrological_wheel(planet_positions, house_results, aspects)

        # Appel pour pr√©parer le contexte √† transmettre au template
        context = prepare_template_context(
            name, results, house_results, aspects, aspects_text,
            birth_datetime_local, birth_datetime_utc, location,
            latitude_dms, longitude_dms, theme_data_json
        )

        print("D√©bogage : Contenu de context avant rendu :", context)

        return render(request, 'birth_results.html', context)

    # Affichage du formulaire pour une requ√™te GET
    print("D√©bogage : Affichage du formulaire 'birth_data_form.html'.")
    return render(request, 'birth_data_form.html')






# PLANETES & MAISONS
def extract_request_parameters(request):
    """Extrait les param√®tres de date, ville et pays depuis la requ√™te GET."""
    selected_date = request.GET.get('date')
    city_of_birth = request.GET.get('city_of_birth')
    country_of_birth = request.GET.get('country_of_birth')
    return selected_date, city_of_birth, country_of_birth


def geolocate_city(city, country):
    """G√©olocalise une ville et un pays et retourne la latitude, longitude et une erreur √©ventuelle."""
    geolocator = Nominatim(user_agent="astroapp")
    location = geolocator.geocode(f"{city}, {country}", timeout=10)
    if not location:
        error_message = "Lieu de naissance introuvable. Veuillez v√©rifier l'orthographe ou entrer un autre lieu."
        print("Erreur :", error_message)
        return None, None, error_message

    print(f"D√©bogage : R√©sultat de la g√©olocalisation - Latitude: {location.latitude}, Longitude: {location.longitude}")
    return location.latitude, location.longitude, None


def determine_timezone(city, country, latitude, longitude):
    """D√©termine le fuseau horaire pour une ville et un pays donn√©s, avec un cas particulier pour Cayenne."""
    if city.lower() == "cayenne" and country.lower() in ["guyane fran√ßaise", "french guiana"]:
        timezone_at = "Etc/GMT+3"  # UTC-3 pour Cayenne
        print("D√©bogage : Fuseau horaire pour Cayenne forc√© √† UTC-3")
    else:
        tf = TimezoneFinder()
        timezone_at = tf.timezone_at(lng=longitude, lat=latitude)
        print(f"Debug - Fuseau horaire d√©tect√© par TimezoneFinder : {timezone_at}")

    if not timezone_at:
        error_message = "Impossible de d√©terminer le fuseau horaire pour ce lieu."
        print("Erreur :", error_message)
        return None, error_message

    return timezone_at, None


def convert_to_utc(date_obj, timezone_str):
    """Convertit un objet datetime en UTC selon le fuseau horaire fourni."""
    try:
        # Applique le fuseau horaire local fourni pour convertir la date en UTC
        local_tz = pytz.timezone(timezone_str)
        print(f"Debug - Application du fuseau horaire : {timezone_str}")
        
        # Si l'objet date n'a pas encore de fuseau horaire, applique local_tz
        if date_obj.tzinfo is None:
            date_obj = local_tz.localize(date_obj)
        
        # Conversion en UTC
        date_utc = date_obj.astimezone(pytz.utc)
        print(f"Debug - Date locale apr√®s application du fuseau : {date_obj}, Date UTC : {date_utc}")
        
        return date_utc, None

    except Exception as e:
        error_message = f"Erreur de conversion du fuseau horaire : {e}"
        print(error_message)
        return None, error_message


# Fonction pour extraire les informations de date
def extract_date_info(selected_date):
    date_obj = datetime.strptime(selected_date, "%Y-%m-%d")
    local_day_str = date_obj.day
    local_month_str = date_obj.strftime("%B")  # Mois sous forme de texte (ex: Janvier)
    local_year_str = date_obj.year
    print(f"D√©bogage : Jour -> {local_day_str}, Mois -> {local_month_str}, Ann√©e -> {local_year_str}")
    return date_obj, local_day_str, local_month_str, local_year_str


# Fonction pour pr√©parer le contexte de rendu HTML
def prepare_planetary_context(selected_date, city_of_birth, country_of_birth, local_day_str, local_month_str, local_year_str, results, house_results):
    return {
        'selected_date': selected_date,
        'city_of_birth': city_of_birth,
        'country_of_birth': country_of_birth,
        'local_day_str': local_day_str,
        'local_month_str': local_month_str,
        'local_year_str': local_year_str,
        'results': results,
        'houses': house_results,
    }

# Fonction pour calculer les positions plan√©taires et les maisons
def calculate_positions_and_houses(jd, latitude, longitude):
    results, planet_positions = calculate_planet_positions(jd)
    house_results = calculate_houses(jd, latitude, longitude)
    
    # Debugging: Afficher les r√©sultats calcul√©s
    print(f"Debug - R√©sultats des positions plan√©taires: {results}")
    print(f"Debug - R√©sultats des maisons astrologiques: {house_results}")
    
    return results, planet_positions, house_results


# Position des Plan√®tes
def planetary_position(request):# Calculer le jour julien (JD)
    # Appel de la foction : def extract_request_parameters
    selected_date, city_of_birth, country_of_birth = extract_request_parameters(request)

    # V√©rifier si les champs requis sont fournis
    if not selected_date or not city_of_birth or not country_of_birth:
        print("Erreur : Champs manquants - date:", selected_date, ", ville:", city_of_birth, ", pays:", country_of_birth)
        return HttpResponse("Tous les champs (date, ville de naissance, pays de naissance) doivent √™tre renseign√©s.")
    
    print("D√©bogage : Variables re√ßues - date:", selected_date, ", ville:", city_of_birth, ", pays:", country_of_birth)

    # Appel de la fonction pour extraire les informations de date : def extract_date_info
    date_obj, local_day_str, local_month_str, local_year_str = extract_date_info(selected_date)

    # Utiliser le geolocator pour obtenir la latitude et la longitude
    print("Debug - Tentative de g√©olocalisation avec geolocator")
    latitude, longitude, error = geolocate_city(city_of_birth, country_of_birth)
    if error:
        return HttpResponse(error)

    # Debugging: Afficher les valeurs de latitude et longitude
    print(f"Debug - Latitude: {latitude}, Longitude: {longitude}")
    print(f"Debug - Ville de naissance: {city_of_birth}, Pays de naissance: {country_of_birth}")


    # Appel √† la fonction pour Fixer manuellement le fuseau horaire si le lieu est Cayenne : def determine_timezone
    timezone_at, error = determine_timezone(city_of_birth, country_of_birth, latitude, longitude)
    if error:
        return HttpResponse(error)
    # Appel √† la fonction
    date_utc, error = convert_to_utc(date_obj, timezone_at)
    if error:
        return HttpResponse(error)

    # Appel de la fonction pour calculer le jour julien (JD) : def calculate_julian_day
    jd = calculate_julian_day(date_utc)

    # Appel de la fonction pour calculer les positions plan√©taireset les maisons : 
    results, planet_positions, house_results = calculate_positions_and_houses(jd, latitude, longitude)

    # Appel de la fonction pour pr√©parer le contexte : def prepare_planetary_context
    context = prepare_planetary_context(
        selected_date, city_of_birth, country_of_birth,
        local_day_str, local_month_str, local_year_str,
        results, house_results
    )
    return render(request, 'planetary_position.html', context)


# 8-Fonction pour convertir les coordonn√©es en DMS
def decimal_to_dms(coordinate, is_latitude=True):
    if is_latitude:
        direction = 'N' if coordinate >= 0 else 'S'
    else:
        direction = 'E' if coordinate >= 0 else 'O'
    abs_coord = abs(coordinate)
    degrees = int(abs_coord)
    minutes = int((abs_coord - degrees) * 60)
    seconds = (abs_coord - degrees - minutes / 60) * 3600
    return f"{degrees}¬∞ {minutes}' {seconds:.2f}\" {direction}"
    
    

    
# ROUE
def extract_wheel_data(request):
    """Extrait les donn√©es de la roue astrologique des param√®tres GET."""
    house_results = json.loads(request.GET.get('house_results', '{}'))
    aspects = json.loads(request.GET.get('aspects', '[]'))
    planet_positions = json.loads(request.GET.get('planet_positions', '[]'))
    return house_results, aspects, planet_positions

def prepare_aspects_text(aspects, planet_positions):
    """Pr√©pare le texte format√© des aspects pour l'affichage."""
    return format_aspects_text(aspects, planet_positions)

def prepare_wheel_context(planet_positions, house_results, aspects_text):
    """Pr√©pare le contexte pour le rendu de la roue astrologique."""
    return {
        'results': planet_positions,
        'houses': house_results,
        'aspects_text': aspects_text
    }

def display_astrological_wheel(request):
    # Appel de la fonciton pour Charger les donn√©es depuis les param√®tres GET : def extract_wheel_data
    house_results, aspects, planet_positions = extract_wheel_data(request)


    # Ajout de d√©bogages pour v√©rifier les donn√©es re√ßues
    print("House Results:", house_results)
    print("Aspects:", aspects)
    print("Planet Positions:", planet_positions)

    # Appel de la fonciotn pour Formater les aspects en texte lisible : def prepare_aspects_text
    aspects_text = prepare_aspects_text(aspects, planet_positions)
    print("D√©bogage - aspects_text apr√®s formatage :", aspects_text)  # V√©rifier le contenu format√©

    # Appel de la fonction pour pr√©parer le contexte pour le rendu et passer les donn√©es format√©es au template : def prepare_wheel_contex
    context = prepare_wheel_context(planet_positions, house_results, aspects_text)
    return render(request, 'birth_results.html', context)



# Fonction g√©n√©rale pour appeler les sous foncitons.
def generate_astrological_wheel(planet_positions, house_results, aspects):
    # D√©finir le chemin d'image
    image_path = os.path.join(settings.BASE_DIR, 'astroapp/static/images/zodiac_wheel.png')

    # Initialiser la figure et les axes
    fig, ax = create_astrological_figure()

    # Calculer l‚Äôoffset de rotation pour aligner l'ascendant √† gauche
    asc_angle = house_results['Maison 1']['degree']
    rotation_offset = np.radians(-asc_angle + 180)

    # Dessiner le cercle principal
    draw_circle(ax)

    # Dessiner les segments color√©s des signes
    draw_segments(ax, rotation_offset)

    # Ajouter les divisions principales et les subdivisions
    draw_divisions(ax, rotation_offset)

    # Placer les symboles des signes du zodiaque
    draw_zodiac_symbols(ax, rotation_offset)

    # Positionner les symboles des plan√®tes selon leurs positions calcul√©es et ajouter les lignes de liaison
    draw_planet_positions(ax, planet_positions, rotation_offset)

    # Ajouter les cuspides des maisons et les triangles pour les maisons principales
    draw_houses_and_cusps(ax, house_results, rotation_offset)

    # Afficher les degr√©s et minutes pour chaque plan√®te et chaque maison
    display_degrees(ax, planet_positions, house_results, rotation_offset)

    # Ajouter les lignes pour l'ASC et le MC avec leurs marqueurs
    draw_asc_mc_lines(ax, house_results, rotation_offset)

    # Ajouter les num√©ros des maisons
    draw_house_numbers(ax, house_results, rotation_offset)
    
    # Appeler draw_aspects pour dessiner les aspects
    draw_aspects(ax, aspects, rotation_offset)


    # Ajuster les limites de l'axe pour ne pas couper les angles
    ax.set_xlim(-2.9, 2.9)
    ax.set_ylim(-2.9, 2.9)

    # Supprimer les marges automatiques et r√©gler la figure pour occuper tout l'espace
    plt.subplots_adjust(left=0, right=1, top=1, bottom=0)
    fig.set_size_inches(12, 12)
    ax.set_aspect('equal')
    
    # Sauvegarder l'image finale
    save_astrological_image(fig, image_path)


def create_astrological_figure():
    # Cr√©er la figure et les axes avec la taille et les limites appropri√©es
    fig, ax = plt.subplots(figsize=(14, 14))  # Dimensions de la figure (modifiables si n√©cessaire)
    ax.set_xlim(-1.5, 1.5)  # Limites de l'axe x
    ax.set_ylim(-1.5, 1.5)  # Limites de l'axe y
    ax.set_aspect('equal')  # Proportions √©gales pour un cercle parfait
    ax.axis('off')  # Masquer les axes pour un rendu propre de la roue astrologique
    
    return fig, ax


def draw_circle(ax):
    # Dessiner le cercle principal qui forme la base de la roue astrologique
    main_circle = plt.Circle((0, 0), 1.2, edgecolor='black', facecolor='none', linewidth=1)
    ax.add_patch(main_circle)
    
    # Ajouter un cercle blanc au centre pour d√©gager la zone centrale
    center_circle = plt.Circle((0, 0), 0.80, color='white', ec='black', linewidth=0.5, zorder=10)
    ax.add_patch(center_circle)
    
    # Ajouter un cercle ext√©rieur pour la bordure de la roue
    outer_border_circle = plt.Circle((0, 0), 1.2, color='none', ec='black', linewidth=0.5, zorder=5)
    ax.add_patch(outer_border_circle)

def get_segment_colors():
    colors_outer = ["#ffbfbf", "#ffdcc0", "#ffeac1", "#fff3bf", "#ffffbf", "#e7fbbe", 
                    "#c0f2bf", "#bfe6e5", "#c4cfeb", "#ccc4eb", "#ccc4eb", "#f1bfda"]
    colors_inner = ["#ffcccb", "#ffe3cb", "#ffe3cd", "#fff6cd", "#ffffcd", "#edfcd5", 
                    "#ccf5cd", "#cceaec", "#d0d8ed", "#d7d0ef", "#d7d0ef", "#f6cce4"]
    return colors_outer, colors_inner

def draw_single_segment(ax, color_outer, color_inner, theta1, theta2):
    """Dessine un segment astrologique en deux arcs (ext√©rieur et int√©rieur) avec des couleurs sp√©cifiques."""
    # Dessiner l'arc ext√©rieur
    arc_outer = patches.Wedge(center=(0, 0), r=1.2, theta1=theta1, theta2=theta2, facecolor=color_outer, zorder=2)
    ax.add_patch(arc_outer)

    # Dessiner l'arc int√©rieur
    arc_inner = patches.Wedge(center=(0, 0), r=1.09, theta1=theta1, theta2=theta2, facecolor=color_inner, zorder=2)
    ax.add_patch(arc_inner)

def draw_segments(ax, rotation_offset):
    # Appel de la fonciton pour les Couleurs des segments par √©l√©ment (feu, terre, air, eau) : def get_segment_colors
    colors_outer, colors_inner = get_segment_colors()

    # Dessiner chaque segment pour les 12 signes
    for i, (color_outer, color_inner) in enumerate(zip(colors_outer, colors_inner)):
        # Calculer l'angle de d√©but pour chaque segment
        angle = 2 * np.pi / 12 * i
        angle_corrected = angle + rotation_offset

        # D√©finir les angles de chaque arc en degr√©s
        theta1 = np.degrees(angle_corrected)
        theta2 = np.degrees(angle_corrected + 2 * np.pi / 12)

        # Appel de la fonction pour Dessiner les arcs ext√©rieur et int√©rieur pour chaque segment : def draw_single_segment
        draw_single_segment(ax, color_outer, color_inner, theta1, theta2)

def draw_main_divisions(ax, rotation_offset):
    """Dessine les divisions principales de 30¬∞ pour chaque signe."""
    for angle in np.linspace(0, 2 * np.pi, 12, endpoint=False):
        angle_corrected = angle + rotation_offset
        x_outer = 1.2 * np.cos(angle_corrected)
        y_outer = 1.2 * np.sin(angle_corrected)
        x_inner = 0.8 * np.cos(angle_corrected)
        y_inner = 0.8 * np.sin(angle_corrected)
        ax.plot([x_outer, x_inner], [y_outer, y_inner], 'k', lw=1)

def draw_subdivisions(ax, rotation_offset):
    """Dessine les subdivisions de 5¬∞ entre chaque division principale."""
    for angle in np.linspace(0, 2 * np.pi, 12, endpoint=False):
        for sub_angle in np.linspace(angle, angle + np.pi / 6, 6, endpoint=False):
            sub_angle_corrected = sub_angle + rotation_offset
            x_sub = 1.2 * np.cos(sub_angle_corrected)
            y_sub = 1.2 * np.sin(sub_angle_corrected)
            x_sub_inner = 1.1 * np.cos(sub_angle_corrected)
            y_sub_inner = 1.1 * np.sin(sub_angle_corrected)
            ax.plot([x_sub, x_sub_inner], [y_sub, y_sub_inner], 'k', lw=0.5)


def draw_divisions(ax, rotation_offset):
    # Appel de la fonction pour ajouter les divisions principales de 30¬∞ pour chaque signe : def draw_main_divisions
    draw_main_divisions(ax, rotation_offset)

    # Appel de la fonction pour ajouter les subdivisions de 5¬∞ entre chaque division principale : def draw_subdivisions
    draw_subdivisions(ax, rotation_offset)


def get_zodiac_data():
    """Retourne les √©l√©ments, les couleurs et les symboles des signes du zodiaque."""
    elements = ['fire', 'earth', 'air', 'water', 
                'fire', 'earth', 'air', 'water', 
                'fire', 'earth', 'air', 'water']

    sign_colors = {
        'fire': "#f9074c",   # B√©lier, Lion, Sagittaire
        'earth': "#c59626",  # Taureau, Vierge, Capricorne
        'air': "#1a8fe9",    # G√©meaux, Balance, Verseau
        'water': "#62ce02"   # Cancer, Scorpion, Poissons
    }

    zodiac_symbols = ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'v', 'x', 'c']
    return elements, sign_colors, zodiac_symbols

def load_zodiac_font():
    """Charge et retourne la police HamburgSymbols pour les symboles du zodiaque."""
    font_path = os.path.join(settings.BASE_DIR, 'astroapp', 'fonts', 'hamburgsymbols', 'HamburgSymbols.ttf')
    return font_manager.FontProperties(fname=font_path)


def draw_zodiac_symbols(ax, rotation_offset):
    # Appel de la fonciton pour associer les √©l√©ments aux signes du zodiaque : def get_zodiac_data
    elements, sign_colors, zodiac_symbols = get_zodiac_data()


    # Liste des symboles zodiacaux (en utilisant des symboles unicode ou police sp√©cifique)
    zodiac_symbols = ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'v', 'x', 'c']
    
    # Appel de la fonciton pour Charger la police HamburgSymbols si n√©cessaire : def load_zodiac_font
    prop = load_zodiac_font()


    # Placer chaque symbole du zodiaque
    for i, symbol in enumerate(zodiac_symbols):
        # Calculer l'angle de positionnement pour chaque signe
        angle = np.radians(30 * i + 15)
        angle_corrected = angle + rotation_offset
        x_text = 0.96 * np.cos(angle_corrected)
        y_text = 0.96 * np.sin(angle_corrected)

        # D√©terminer la couleur du signe en fonction de son √©l√©ment
        element = elements[i]
        symbol_color = sign_colors[element]

        # D√©finir la taille du symbole zodiacal en fonction de la figure
        symbol_size = 40  # Ajustable si n√©cessaire

        # Ajouter le symbole √† la figure
        ax.text(x_text, y_text, symbol, fontsize=symbol_size, 
                ha='center', va='center', fontproperties=prop, color=symbol_color)


def get_planet_data():
    """Retourne les symboles et couleurs des plan√®tes."""
    planet_symbols = {
        'Soleil': 'Q', 'Lune': 'W', 'Mercure': 'E', 'V√©nus': 'R', 
        'Mars': 'T', 'Jupiter': 'Y', 'Saturne': 'U', 'Uranus': 'I', 
        'Neptune': 'O', 'Pluton': 'P'
    }
    
    planet_colors = {
        'Soleil': '#FFA801', 'Lune': '#FFA801', 'Mercure': '#A9CE02', 'V√©nus': '#BB55A1',
        'Mars': '#F9074C', 'Jupiter': '#07B3F2', 'Saturne': '#6A3D90', 
        'Uranus': '#9B207B', 'Neptune': '#07B3F2', 'Pluton': '#3B2B7B'
    }
    
    return planet_symbols, planet_colors


def place_planet(ax, planet, degree, rotation_offset, prop, planet_symbols, planet_colors):
    """Place une plan√®te √† sa position correcte et trace la ligne de liaison."""
    # Calcul de l'angle de la plan√®te en radians
    angle = np.radians(degree)
    angle_corrected = angle + rotation_offset
    x = 1.7 * np.cos(angle_corrected)
    y = 1.7 * np.sin(angle_corrected)
    
    # R√©cup√©rer le symbole et la couleur de la plan√®te
    symbol = planet_symbols.get(planet, "?")
    color = planet_colors.get(planet, '#000000')  # Couleur noire par d√©faut si aucune correspondance

    # Ajouter le symbole de la plan√®te avec sa couleur et sa position
    ax.text(x, y, symbol, fontproperties=prop, fontsize=40, color=color, 
            ha='center', va='center')
    
    # Tracer une ligne de liaison entre le centre et la position de la plan√®te
    ax.plot([0, 0.9 * x], [0, 0.9 * y], color='black', lw=0.5, zorder=1)


def draw_planet_positions(ax, planet_positions, rotation_offset):
    # Appel de la fonction pour r√©cup√©rer les symboles et couleurs des plan√®tes : def get_planet_data
    planet_symbols, planet_colors = get_planet_data()

    # Police HamburgSymbols pour les symboles plan√©taires
    font_path = os.path.join(settings.BASE_DIR, 'astroapp', 'fonts', 'hamburgsymbols', 'HamburgSymbols.ttf')
    prop = font_manager.FontProperties(fname=font_path)

    # Placer chaque plan√®te √† sa position respective et ajouter les lignes de liaison
    for planet, degree in planet_positions:
        
        # Appel de la fonction pour placer chaque plan√®te : def place_planet
        place_planet(ax, planet, degree, rotation_offset, prop, planet_symbols, planet_colors)

# Les lignes
def add_house_cusps(ax, house_results, rotation_offset):
    """Ajoute les lignes de cuspides pour chaque maison sur la roue astrologique."""
    for i, (house, house_data) in enumerate(house_results.items()):
        # R√©cup√©rer l'angle en degr√©s pour chaque cuspide de maison
        degree = house_data['degree']
        angle = np.radians(degree)
        angle_corrected = angle + rotation_offset
        
        # Calculer la position pour la ligne de la cuspide de la maison
        x_pos = 1.27 * np.cos(angle_corrected)
        y_pos = 1.27 * np.sin(angle_corrected)
        ax.plot([0, x_pos], [0, y_pos], color='black', lw=0.7, zorder=1)  # Ligne de cuspide de maison
        
# Les Triangles
def add_house_triangles(ax, house_results, rotation_offset):
    """Ajoute les triangles pour marquer les cuspides des maisons principales et secondaires."""
    for i, (house, house_data) in enumerate(house_results.items()):
        degree = house_data['degree']
        angle_corrected = np.radians(degree) + rotation_offset
        x_triangle = 1.26 * np.cos(angle_corrected)
        y_triangle = 1.26 * np.sin(angle_corrected)
        facecolor = 'black' if i + 1 in [1, 4, 7, 10] else 'white'
        triangle = patches.RegularPolygon((x_triangle, y_triangle), numVertices=3, radius=0.05,
                                          orientation=angle_corrected + np.pi / 2,
                                          edgecolor='black', facecolor=facecolor,
                                          linewidth=1.0, zorder=3)
        ax.add_patch(triangle)
               
# Les lignes et les triangles
def draw_houses_and_cusps(ax, house_results, rotation_offset):
    # Appel de la fonction pour ajouter les LIGNES de cuspides pour chaque maison : def add_house_cusps
    add_house_cusps(ax, house_results, rotation_offset)

    # Appel de la fonction pour ajouter les TRIANGLES pour chaque maison : def add_house_triangles
    add_house_triangles(ax, house_results, rotation_offset)


def get_planet_colors():
    """Retourne le dictionnaire des couleurs pour chaque plan√®te."""
    return {
        'Soleil': '#FFA801', 'Lune': '#FFA801', 'Mercure': '#A9CE02', 'V√©nus': '#BB55A1',
        'Mars': '#F9074C', 'Jupiter': '#07B3F2', 'Saturne': '#6A3D90', 
        'Uranus': '#9B207B', 'Neptune': '#07B3F2', 'Pluton': '#3B2B7B'
    }


def display_planet_degrees(ax, planet_positions, rotation_offset, planet_colors):
    """Affiche les degr√©s et minutes pour chaque plan√®te sur la roue astrologique."""
    for planet, degree in planet_positions:
        angle = np.radians(degree)
        angle_corrected = angle + rotation_offset

        degree_in_sign = degree % 30
        minutes = int((degree_in_sign - int(degree_in_sign)) * 60)

        x_degree = 1.94 * np.cos(angle_corrected)
        y_degree = 1.94 * np.sin(angle_corrected)
        
        x_minutes = 2.10 * np.cos(angle_corrected)
        y_minutes = 2.10 * np.sin(angle_corrected)
        
        degree_color = planet_colors.get(planet, 'black')

        ax.text(x_degree, y_degree, f"{int(degree_in_sign)}¬∞", fontsize=13, 
                ha='center', va='center', color=degree_color, weight='bold')
        ax.text(x_minutes, y_minutes, f"{minutes}'", fontsize=11, 
                ha='center', va='center', color=degree_color, weight='bold')


def display_house_degrees(ax, house_results, rotation_offset):
    """Affiche les degr√©s et minutes pour chaque cuspide de maison sur la roue astrologique."""
    for i, (house, house_data) in enumerate(house_results.items()):
        degree = house_data['degree']
        angle = np.radians(degree)
        angle_corrected = angle + rotation_offset
        
        degree_in_sign = degree % 30
        minutes = int((degree_in_sign - int(degree_in_sign)) * 60)

        x_degree = 1.38 * np.cos(angle_corrected)
        y_degree = 1.38 * np.sin(angle_corrected)
        
        x_minutes = 1.5 * np.cos(angle_corrected)
        y_minutes = 1.5 * np.sin(angle_corrected)
        
        ax.text(x_degree, y_degree, f"{int(degree_in_sign)}¬∞", fontsize=11, 
                ha='center', va='center', color='black')
        ax.text(x_minutes, y_minutes, f"{minutes}'", fontsize=8, 
                ha='center', va='center', color='black')


def display_degrees(ax, planet_positions, house_results, rotation_offset):
    # Appelle de la fonction du Dictionnaire des couleurs des plan√®tes : def get_planet_colors
    planet_colors = get_planet_colors()

    # Appelle de la fonction pour l'Affichage des degr√©s pour chaque plan√®te : def display_planet_degrees
    display_planet_degrees(ax, planet_positions, rotation_offset, planet_colors)

    # Appelle de la fonction pour l'Affichage des degr√©s pour chaque cuspide de maison (en noir) : def display_house_degrees
    display_house_degrees(ax, house_results, rotation_offset)



def draw_asc_mc_marker(ax, label, degree, rotation_offset):
    """Dessine la ligne, le marqueur et le label pour l'ASC ou le MC."""
    angle = np.radians(degree)
    angle_corrected = angle + rotation_offset
    x_pos = 2.3 * np.cos(angle_corrected)
    y_pos = 2.3 * np.sin(angle_corrected)

    ax.plot([0, x_pos], [0, y_pos], color='black', lw=0.5, zorder=1)

    if label == 'ASC':
        triangle = patches.RegularPolygon((x_pos, y_pos), numVertices=3, radius=0.20,
                                          orientation=angle_corrected + np.radians(270),
                                          edgecolor='black', facecolor='white', lw=0.5, zorder=3)
        ax.add_patch(triangle)
        ax.text(x_pos + 0.4 * np.cos(angle_corrected), y_pos + 0.4 * np.sin(angle_corrected), 
                'ASC', fontsize=12, ha='center', va='center', color='black', weight='bold')

    elif label == 'MC':
        circle = plt.Circle((x_pos, y_pos), 0.20, facecolor='white', edgecolor='black', lw=0.5, zorder=2)
        ax.add_patch(circle)
        ax.text(x_pos + 0.35 * np.cos(angle_corrected), y_pos + 0.35 * np.sin(angle_corrected), 
                'MC', fontsize=12, ha='center', va='center', color='black', weight='bold')


def draw_asc_mc_lines(ax, house_results, rotation_offset):
    # Dictionnaire pour associer ASC et MC aux maisons
    asc_mc_houses = {'ASC': 'Maison 1', 'MC': 'Maison 10'}

    # Ajouter une ligne et un marqueur pour chaque √©l√©ment (ASC et MC)
    for label, house_key in asc_mc_houses.items():
        # R√©cup√©rer le degr√© de la maison associ√©e (Maison 1 pour ASC, Maison 10 pour MC)
        degree = house_results[house_key]['degree']

        # Appel de la fonction pour dessiner la ligne, le marqueur et le label
        draw_asc_mc_marker(ax, label, degree, rotation_offset)




def get_roman_numerals():
    """Renvoie un dictionnaire associant les num√©ros de maisons aux chiffres romains."""
    return {
        1: "I", 2: "II", 3: "III", 4: "IV",
        5: "V", 6: "VI", 7: "VII", 8: "VIII",
        9: "IX", 10: "X", 11: "XI", 12: "XII"
    }


def calculate_house_position(degree_start, degree_end, rotation_offset):
    """Calcule la position x, y pour un num√©ro de maison au centre de son segment."""
    if degree_end < degree_start:
        degree_end += 360
    degree_mid = (degree_start + degree_end) / 2
    angle_mid = np.radians(degree_mid) + rotation_offset
    x_text = 1.28 * np.cos(angle_mid)
    y_text = 1.28 * np.sin(angle_mid)
    return x_text, y_text

def draw_house_numbers(ax, house_results, rotation_offset):
    # Dictionnaire pour convertir les num√©ros de maisons en chiffres romains


    # Positionner chaque num√©ro de maison au centre de son segment
    for i in range(len(house_results)):
        # Obtenir les angles des cuspides de chaque maison
        degree_start = house_results[f'Maison {i + 1}']['degree']
        degree_end = house_results[f'Maison {(i + 2) if (i + 2) <= 12 else 1}']['degree']
        
        # Appel de la fonciton pour Ajuster si le segment traverse 0¬∞ : def calculate_house_position
        x_text, y_text = calculate_house_position(degree_start, degree_end, rotation_offset)
        
        # Appel de la fonciton pour Afficher le num√©ro de maison au centre de chaque segment : def get_roman_numerals
        roman_house_num = get_roman_numerals()[i + 1]
        
        ax.text(x_text, y_text, roman_house_num, fontsize=12, ha='center', va='center', color='black', weight='bold')


def get_aspect_style(type_aspect):
    """Retourne le style pour le type d'aspect donn√©, ou None si non d√©fini."""
    aspect_styles = {
        'Opposition': {'color': 'red', 'linestyle': (0, (10, 5)), 'linewidth': 1.0},
        'Trigone': {'color': 'blue', 'linestyle': '-', 'linewidth': 0.8},
        'Carr√©': {'color': 'red', 'linestyle': (0, (10, 5)), 'linewidth': 1.0},
        'Sextile': {'color': 'blue', 'linestyle': '-', 'linewidth': 0.8},
    }
    return aspect_styles.get(type_aspect)


def calculate_aspect_positions(pos1, pos2, rotation_offset):
    """Calcule les positions corrig√©es pour les lignes d'aspect en fonction de l'angle et du d√©calage."""
    angle1 = np.radians(pos1) + rotation_offset
    angle2 = np.radians(pos2) + rotation_offset
    x1, y1 = 0.8 * np.cos(angle1), 0.8 * np.sin(angle1)
    x2, y2 = 0.8 * np.cos(angle2), 0.8 * np.sin(angle2)
    return x1, y1, x2, y2


def draw_aspects(ax, aspects, rotation_offset):
    """
    Dessine les aspects astrologiques entre les plan√®tes sur la roue astrologique.

    Param√®tres :
    - ax : objet Axe de Matplotlib sur lequel la roue astrologique est dessin√©e.
    - aspects : liste de tuples contenant les informations sur chaque aspect. 
                Chaque tuple est de la forme (type_aspect, pos1, pos2),
                o√π type_aspect est le type d'aspect ('opposition', 'trigone', etc.)
                et pos1, pos2 sont les positions angulaires des deux plan√®tes en degr√©s.
    - rotation_offset : d√©calage angulaire pour aligner les aspects sur la roue.
    """
    # Param√®tres de style pour chaque type d'aspect
    aspect_styles = {
        'Opposition': {'color': 'red', 'linestyle': (0, (10, 5)), 'linewidth': 1.0},  # Tirets longs
        'Trigone': {'color': 'blue', 'linestyle': '-', 'linewidth': 0.8},
        'Carr√©': {'color': 'red', 'linestyle': (0, (10, 5)), 'linewidth': 1.0},  # Tirets longs
        'Sextile': {'color': 'blue', 'linestyle': '-', 'linewidth': 0.8},
    }

    for aspect in aspects:
        type_aspect, pos1, pos2 = aspect
        # Appel de la fonciotn pour Obtenir le style pour le type d'aspect : def get_aspect_style
        style = get_aspect_style(type_aspect)
        if not style:
            continue


        # Appel de la fonciotn pour Appliquer le d√©calage de rotation et... :  def calculate_aspect_positions
        # Calculer les positions des extr√©mit√©s des lignes d'aspect
        x1, y1, x2, y2 = calculate_aspect_positions(pos1, pos2, rotation_offset)


        # Dessiner la ligne d'aspect
        ax.plot([x1, x2], [y1, y2], color=style['color'], linestyle=style['linestyle'], linewidth=style['linewidth'], zorder=10)



def deserialize_wheel_data(house_results_str, aspects_str, planet_positions_str):
    """D√©s√©rialise les donn√©es JSON pour les maisons, les aspects et les positions plan√©taires."""
    try:
        house_results = json.loads(house_results_str)
        aspects = json.loads(aspects_str)
        planet_positions = json.loads(planet_positions_str)
    except json.JSONDecodeError as e:
        # Si erreur de d√©s√©rialisation, initialiser avec des valeurs vides
        house_results, aspects, planet_positions = {}, [], []
        print("Erreur de d√©s√©rialisation :", e)

    # Afficher les donn√©es apr√®s d√©s√©rialisation pour v√©rification
    print("D√©bogage - house_results:", house_results)
    print("D√©bogage - aspects:", aspects)
    print("D√©bogage - planet_positions:", planet_positions)

    return house_results, aspects, planet_positions


def birth_results(request):
    # R√©cup√©ration simplifi√©e des donn√©es de th√®me
    house_results = {}
    aspects = []
    planet_positions = {}

    # Affichage pour v√©rification (optionnel)
    print("Donn√©es pour Affichage :", {
        'house_results': house_results,
        'aspects': aspects,
        'planet_positions': planet_positions,
    })

    # Rendre les donn√©es au template
    return render(request, 'birth_results.html', {
        'house_results': house_results,
        'aspects': aspects,
        'planet_positions': planet_positions,
    })






# FIN 
def remove_existing_image(image_path):
    """Supprime l'image existante √† un chemin donn√© si elle est pr√©sente."""
    if os.path.exists(image_path):
        os.remove(image_path)
        print(f"Ancienne image supprim√©e : {image_path}")
    else:
        print(f"Aucune ancienne image √† supprimer : {image_path}")


def save_astrological_image(fig, image_path):

    # Appel de la fonction pour supprimer l'image existante si elle existe : def remove_existing_image
    remove_existing_image(image_path)


    # Sauvegarder la nouvelle image g√©n√©r√©e
    try:
        fig.savefig(image_path, dpi=300)
        print(f"L'image a √©t√© sauvegard√©e avec succ√®s √† : {image_path}")
    except Exception as e:
        print(f"Erreur lors de la g√©n√©ration de l'image : {e}")
    finally:
        plt.close(fig)  # Fermer la figure pour lib√©rer la m√©moire



Fichier : views_functions_variables.py
-------------------------------------
import ast

class OrderedFunctionAnalyzer(ast.NodeVisitor):
    def __init__(self):
        self.ordered_functions = []

    def visit_FunctionDef(self, node):
        # Stocker le nom de la fonction, ses arguments, et sa docstring
        function_info = {
            "name": node.name,
            "args": [arg.arg for arg in node.args.args],
            "variables": [],
            "docstring": ast.get_docstring(node),
            "lineno": node.lineno  # Enregistre le num√©ro de ligne pour garder l'ordre
        }

        # Ajouter les variables locales d√©finies dans la fonction
        for sub_node in ast.walk(node):
            if isinstance(sub_node, ast.Assign):
                for target in sub_node.targets:
                    if isinstance(target, ast.Name):
                        function_info["variables"].append(target.id)

        self.ordered_functions.append(function_info)
        self.generic_visit(node)

# Charger le fichier views.py pour l'analyser
with open('views.py', 'r', encoding='utf-8') as file:
    tree = ast.parse(file.read())

analyzer = OrderedFunctionAnalyzer()
analyzer.visit(tree)

# Trier les fonctions par num√©ro de ligne pour les afficher dans l'ordre d'apparition
analyzer.ordered_functions.sort(key=lambda x: x["lineno"])

# Affichage de toutes les fonctions avec num√©rotation dans l'ordre d'apparition
print(f"Nombre total de fonctions trouv√©es : {len(analyzer.ordered_functions)}\n")
for index, func in enumerate(analyzer.ordered_functions, start=1):
    print(f"Fonction {index}: {func['name']}")
    print(f"  Arguments : {', '.join(func['args'])}")
    print(f"  Variables locales : {', '.join(func['variables'])}")
    if func['docstring']:
        print(f"  Description : {func['docstring']}")
    else:
        print("  Description : Aucune description")
    print()

# V√©rification des fonctions sans description
missing_descriptions = [func for func in analyzer.ordered_functions if not func['docstring']]
if missing_descriptions:
    print("Fonctions manquant de descriptions :")
    for func in missing_descriptions:
        print(f"- {func['name']}")
else:
    print("Toutes les fonctions ont une description.")


Fichier : __init__.py
--------------------


Dossier : /mnt/e/CALENDAR/astro/astroapp/fonts
=============================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/fonts/hamburgsymbols
============================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/fonts/hamburgsymbols/demo-files
=======================================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/management
==================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/management/commands
===========================================================

Fichier : delete_migrations.py
-----------------------------
from django.core.management.base import BaseCommand
from django.db import connection

class Command(BaseCommand):
    help = "Supprime les entr√©es de migration de l'application astroapp dans la base de donn√©es."

    def handle(self, *args, **kwargs):
        with connection.cursor() as cursor:
            cursor.execute("DELETE FROM django_migrations WHERE app = 'astroapp';")
            self.stdout.write(self.style.SUCCESS("Les migrations pour 'astroapp' ont √©t√© supprim√©es de la base de donn√©es."))


Dossier : /mnt/e/CALENDAR/astro/astroapp/management/commands/__pycache__
=======================================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/migrations
==================================================

Fichier : 0001_initial.py
------------------------
# Generated by Django 5.1.1 on 2024-11-18 06:17

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ThemeAstrologique',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom_du_theme', models.CharField(max_length=255)),
                ('date_de_creation', models.DateTimeField(auto_now_add=True)),
                ('date_naissance', models.DateField(default='2000-01-01')),
                ('heure_naissance', models.TimeField(default='00:00:00')),
                ('pays', models.CharField(max_length=255)),
                ('ville', models.CharField(max_length=255)),
                ('utilisateur', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]


Fichier : __init__.py
--------------------


Dossier : /mnt/e/CALENDAR/astro/astroapp/migrations/__pycache__
==============================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/static
==============================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/static/images
=====================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/static/js
=================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/templates
=================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/templates/registration
==============================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/templatetags
====================================================

Fichier : custom_filters.py
--------------------------
from django import template

register = template.Library()

@register.filter
def degrees_minutes(value):
    degrees = int(value)
    minutes = int((value - degrees) * 60)  # On tronque les minutes
    seconds = round(((value - degrees) * 60 - minutes) * 60, 2)
    return f"{degrees}¬∞{minutes}'"


Fichier : __init__.py
--------------------


Dossier : /mnt/e/CALENDAR/astro/astroapp/templatetags/__pycache__
================================================================

Dossier : /mnt/e/CALENDAR/astro/astroapp/__pycache__
===================================================

Dossier : /mnt/e/CALENDAR/astro/astroconfig
==========================================

Fichier : asgi.py
----------------


Fichier : settings.py
--------------------
from pathlib import Path
import os


# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-your_secret_key_here'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []
LOGIN_URL = '/connexion/'

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'astroapp',  # L'application 'astroapp'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'astroconfig.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'astroconfig.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

# Dossier pour les fichiers statiques (images, CSS, etc.)
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'astroapp', 'static')]

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


Fichier : urls.py
----------------
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('astroapp.urls')),  # Inclut les URLs de l'application `astroapp`
]


Fichier : wsgi.py
----------------
"""
WSGI config for astroconfig project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named 'application'. Django's 'runserver' and 'gunicorn' are two examples of
servers that use this configuration pattern.
"""

import os
from django.core.wsgi import get_wsgi_application

# Set the settings module accordingly
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'astroconfig.settings')

application = get_wsgi_application()


Fichier : __init__.py
--------------------


Dossier : /mnt/e/CALENDAR/astro/astroconfig/__pycache__
======================================================

